#![feature(new_uninit, box_syntax)]

pub mod cpu;
pub mod debug_info;
pub mod elf;
pub mod exec;
pub mod lifter;
pub mod utils;

mod config;
mod exit;
mod regs;
mod trace;

use std::{
    any::Any,
    collections::{HashMap, HashSet},
};

use crate::debug_info::SourceLocation;

pub use crate::{
    config::Config,
    cpu::{Arch, Cpu, CpuSnapshot, Exception, Hook, ShadowStack, ShadowStackEntry},
    exit::VmExit,
    lifter::BlockGroup,
    regs::{RegValue, Regs, ValueSource, VarSource},
    trace::{StoreRef, TraceStore},
};
pub use icicle_mem as mem;
pub use icicle_mem::Mmu;

#[derive(Copy, Clone, Debug, Default, Hash, PartialEq, Eq)]
pub struct BlockKey {
    pub vaddr: u64,
    pub isa_mode: u64,
}

/// Keeps track of all the code in the program that the emulator has discovered.
#[derive(Default)]
pub struct BlockTable {
    pub map: HashMap<BlockKey, BlockGroup>,
    pub blocks: Vec<lifter::Block>,
    pub disasm: HashMap<u64, String>,
    pub breakpoints: HashSet<u64>,
    pub modified: HashSet<usize>,
}

impl BlockTable {
    pub fn flush_code(&mut self) {
        self.map.clear();
        self.blocks.clear();
        self.disasm.clear();
        self.modified.clear();
    }
}

pub trait Environment {
    /// Loads the target into the enviroment.
    fn load(&mut self, cpu: &mut Cpu, path: &[u8]) -> Result<(), String>;

    /// Called whenever an exception is generated by the CPU.
    fn handle_exception(&mut self, cpu: &mut Cpu) -> Option<VmExit>;

    /// Returns the next time the environment wants to interrupt the CPU.
    fn next_timer(&self) -> u64 {
        u64::MAX
    }

    /// Obtains debug information about the target address.
    fn symbolize_addr(&mut self, _cpu: &mut Cpu, _addr: u64) -> Option<SourceLocation> {
        None
    }

    /// Looks up symbol in the environment
    fn lookup_symbol(&mut self, _symbol: &str) -> Option<u64> {
        None
    }

    /// Gets the address of the program entrypoint.
    // @note: currently only used for debugging, currently `load` is expected to configure the cpu
    // with the entrypoint.
    fn entry_point(&mut self) -> u64 {
        0
    }

    /// Creates a snapshot of the current state of the environment which can be restored later.
    fn snapshot(&mut self) -> Box<dyn Any>;

    /// Restores the environment to the state of the snapshot.
    fn restore(&mut self, snapshot: &Box<dyn Any>);

    fn as_any(&mut self) -> &mut dyn Any;
}

impl Environment for () {
    fn load(&mut self, _: &mut Cpu, _: &[u8]) -> Result<(), String> {
        Err("No environment loaded".into())
    }
    fn handle_exception(&mut self, _: &mut Cpu) -> Option<VmExit> {
        None
    }
    fn snapshot(&mut self) -> Box<dyn Any> {
        Box::new(())
    }
    fn restore(&mut self, _: &Box<dyn Any>) {}
    fn as_any(&mut self) -> &mut dyn Any {
        self
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[repr(u32)]
pub enum ExceptionCode {
    None = 0x0000,

    InstructionLimit = 0x0001,
    Halt = 0x0002,

    Syscall = 0x0101,
    CpuStateChanged = 0x0102,
    DivideByZero = 0x0103,

    ReadUnmapped = 0x0201,
    ReadPerm = 0x0202,
    ReadUnaligned = 0x0203,
    ReadWatch = 0x0204,
    ReadUninitialized = 0x0205,

    WriteUnmapped = 0x0301,
    WritePerm = 0x0302,
    WriteWatch = 0x0303,
    WriteUnaligned = 0x0304,

    ExecViolation = 0x0401,
    SelfModifyingCode = 0x0402,
    OutOfMemory = 0x0501,

    InvalidInstruction = 0x1001,
    UnknownInterrupt = 0x1002,
    UnknownCpuID = 0x1003,
    InvalidOpSize = 0x1004,
    InvalidFloatSize = 0x1005,
    CodeNotTranslated = 0x1006,
    ShadowStackOverflow = 0x1007,
    ShadowStackInvalid = 0x1008,
    InvalidTarget = 0x1009,
    UnimplementedOp = 0x100a,

    ExternalAddr = 0x2001,
    Environment = 0x2002,

    JitError = 0x3001,
    InternalError = 0x3002,

    UnknownError,
}

impl ExceptionCode {
    #[inline]
    pub fn from_u32(code: u32) -> Self {
        match code {
            0x0000 => Self::None,
            0x0001 => Self::InstructionLimit,
            0x0002 => Self::Halt,

            0x0101 => Self::Syscall,
            0x0102 => Self::CpuStateChanged,
            0x0103 => Self::DivideByZero,

            0x0201 => Self::ReadUnmapped,
            0x0202 => Self::ReadPerm,
            0x0203 => Self::ReadUnaligned,
            0x0204 => Self::ReadWatch,
            0x0205 => Self::ReadUninitialized,

            0x0301 => Self::WriteUnmapped,
            0x0302 => Self::WritePerm,
            0x0303 => Self::WriteWatch,
            0x0304 => Self::WriteUnaligned,

            0x0401 => Self::ExecViolation,
            0x0402 => Self::SelfModifyingCode,
            0x0501 => Self::OutOfMemory,

            0x1001 => Self::InvalidInstruction,
            0x1002 => Self::UnknownInterrupt,
            0x1003 => Self::UnknownCpuID,
            0x1004 => Self::InvalidOpSize,
            0x1005 => Self::InvalidFloatSize,
            0x1006 => Self::CodeNotTranslated,
            0x1007 => Self::ShadowStackOverflow,
            0x1008 => Self::ShadowStackInvalid,
            0x1009 => Self::InvalidTarget,
            0x100a => Self::UnimplementedOp,

            0x2001 => Self::ExternalAddr,
            0x2002 => Self::Environment,

            0x3001 => Self::JitError,
            0x3002 => Self::InternalError,

            _ => {
                if cfg!(debug_assertions) {
                    panic!("Unknown exception code: {:#0x}", code);
                }
                Self::UnknownError
            }
        }
    }

    pub fn is_running(&self) -> bool {
        matches!(self, Self::None | Self::InstructionLimit)
    }

    pub fn is_memory_error(&self) -> bool {
        matches!(
            self,
            Self::ReadUnmapped
                | Self::ReadPerm
                | Self::ReadUnaligned
                | Self::ReadWatch
                | Self::ReadUninitialized
                | Self::WriteUnmapped
                | Self::WritePerm
                | Self::WriteWatch
                | Self::WriteUnaligned
                | Self::SelfModifyingCode
        )
    }

    pub fn from_load_error(err: icicle_mem::MemError) -> Self {
        use icicle_mem::MemError;
        match err {
            MemError::Unmapped => Self::ReadUnmapped,
            MemError::Uninitalized => Self::ReadUninitialized,
            MemError::ReadViolation => Self::ReadPerm,
            MemError::Unaligned => Self::ReadUnaligned,
            MemError::ReadWatch => Self::ReadWatch,
            _ => Self::from(err),
        }
    }

    pub fn from_store_error(err: icicle_mem::MemError) -> Self {
        use icicle_mem::MemError;
        match err {
            MemError::Unmapped => Self::WriteUnmapped,
            MemError::WriteViolation => Self::WritePerm,
            MemError::Unaligned => Self::WriteUnaligned,
            MemError::WriteWatch => Self::WriteWatch,
            _ => Self::from(err),
        }
    }
}

impl From<icicle_mem::MemError> for ExceptionCode {
    fn from(err: icicle_mem::MemError) -> Self {
        use icicle_mem::MemError;
        match err {
            MemError::Unmapped => Self::ReadUnmapped,
            MemError::Uninitalized => Self::ReadUninitialized,
            MemError::ReadViolation => Self::ReadPerm,
            MemError::WriteViolation => Self::WritePerm,
            MemError::ExecViolation => Self::ExecViolation,
            MemError::ReadWatch => Self::ReadWatch,
            MemError::WriteWatch => Self::WriteWatch,
            MemError::Unaligned => Self::ReadUnaligned,
            MemError::OutOfMemory => Self::OutOfMemory,
            MemError::SelfModifyingCode => Self::SelfModifyingCode,

            // These are errors that should be handled by the memory subsystem.
            MemError::Unallocated | MemError::Unknown => Self::UnknownError,
        }
    }
}

#[derive(Copy, Clone)]
#[repr(u64)]
pub enum InternalError {
    CorruptedBlockMap,
}
